# ContextFileConcat Output
# Generated: 2025-07-15 01:13:37
# Total files: 12

/Users/penrose/dev/D/context-file-concat/src/utils/file_detection.rs
----------------------------------------------------
use std::path::Path;
use std::fs::File;
use std::io::{BufReader, Read};
use anyhow::Result;

const TEXT_EXTENSIONS: &[&str] = &[
    "txt", "md", "markdown", "rst", "asciidoc", "adoc",
    "rs", "py", "js", "ts", "jsx", "tsx", "java", "c", "cpp", "cxx", "cc", "h", "hpp", "hxx",
    "go", "rb", "php", "swift", "kt", "kts", "scala", "clj", "cljs", "hs", "ml", "fs", "fsx",
    "html", "htm", "xml", "xhtml", "css", "scss", "sass", "less", "svg", "vue", "svelte",
    "json", "yaml", "yml", "toml", "ini", "cfg", "conf", "config", "properties",
    "sql", "sh", "bash", "zsh", "fish", "ps1", "bat", "cmd", "dockerfile", "makefile", "cmake",
    "gradle", "maven", "pom", "build", "tex", "bib", "r", "m", "pl", "lua", "vim", "el", "lisp",
    "dart", "elm", "ex", "exs", "erl", "hrl", "nim", "crystal", "cr", "zig", "odin", "v",
    "log", "trace", "out", "err", "diff", "patch", "gitignore", "gitattributes", "editorconfig",
    "env", "example", "sample", "template", "spec", "test", "readme", "license", "changelog",
    "todo", "notes", "doc", "docs", "man", "help", "faq",
];

const IMAGE_EXTENSIONS: &[&str] = &[
    "jpg", "jpeg", "png", "gif", "bmp", "ico", "webp", // SVG ENTFERNT - ist jetzt nur Text
    "tiff", "tif", "raw", "cr2", "nef", "orf", "dng",
    "heic", "heif", "avif", "jfif",
];

const BINARY_EXTENSIONS: &[&str] = &[
    "exe", "dll", "so", "dylib", "app", "deb", "rpm", "msi",
    "zip", "tar", "gz", "bz2", "7z", "rar", "jar", "war",
    "mp3", "mp4", "avi", "mkv", "mov", "wmv", "flv", "webm",
    "pdf", "doc", "docx", "xls", "xlsx", "ppt", "pptx",
    "bin", "dat", "db", "sqlite", "sqlite3",
];

/// Determines if a file is likely to be a text file
pub fn is_text_file(path: &Path) -> Result<bool> {
    // First check by extension
    if let Some(extension) = path.extension().and_then(|ext| ext.to_str()) {
        let ext_lower = extension.to_lowercase();
        
        // Known text extensions - SVG wird hier als Text erkannt
        if TEXT_EXTENSIONS.contains(&ext_lower.as_str()) {
            return Ok(true);
        }
        
        // Known binary extensions
        if BINARY_EXTENSIONS.contains(&ext_lower.as_str()) {
            return Ok(false);
        }
        
        // Known image extensions (now without SVG)
        if IMAGE_EXTENSIONS.contains(&ext_lower.as_str()) {
            return Ok(false);
        }
    }
    
    // If extension is unknown, check file content
    check_file_content(path)
}

/// Determines if a file is an image file (für Icon-Anzeige)
pub fn is_image_file(path: &Path) -> bool {
    if let Some(extension) = path.extension().and_then(|ext| ext.to_str()) {
        let ext_lower = extension.to_lowercase();
        // SVG wird hier NICHT als Image behandelt für Icons, aber kann später erweitert werden
        IMAGE_EXTENSIONS.contains(&ext_lower.as_str()) || ext_lower == "svg"
    } else {
        false
    }
}

/// Checks file content to determine if it's text or binary
fn check_file_content(path: &Path) -> Result<bool> {
    let file = File::open(path)?;
    let mut reader = BufReader::new(file);
    let mut buffer = [0; 1024]; // Read first 1KB
    
    let bytes_read = reader.read(&mut buffer)?;
    
    if bytes_read == 0 {
        return Ok(true); // Empty file, consider as text
    }
    
    // Check for null bytes (common in binary files)
    if buffer[..bytes_read].contains(&0) {
        return Ok(false);
    }
    
    // Check UTF-8 validity
    match std::str::from_utf8(&buffer[..bytes_read]) {
        Ok(_) => Ok(true),
        Err(_) => {
            // Try to detect common text encodings
            // For simplicity, we'll be conservative and say it's binary
            // if it's not valid UTF-8
            Ok(false)
        }
    }
}

/// Get a human-readable file type description
pub fn get_file_type_description(path: &Path) -> String {
    if let Some(extension) = path.extension().and_then(|ext| ext.to_str()) {
        let ext_lower = extension.to_lowercase();
        
        match ext_lower.as_str() {
            "rs" => "Rust source".to_string(),
            "py" => "Python script".to_string(),
            "js" => "JavaScript".to_string(),
            "ts" => "TypeScript".to_string(),
            "java" => "Java source".to_string(),
            "c" => "C source".to_string(),
            "cpp" | "cxx" | "cc" => "C++ source".to_string(),
            "h" | "hpp" => "Header file".to_string(),
            "html" | "htm" => "HTML document".to_string(),
            "css" => "Stylesheet".to_string(),
            "json" => "JSON data".to_string(),
            "xml" => "XML document".to_string(),
            "svg" => "SVG vector image".to_string(), // Spezielle Behandlung für SVG
            "md" | "markdown" => "Markdown document".to_string(),
            "txt" => "Text file".to_string(),
            "pdf" => "PDF document".to_string(),
            "jpg" | "jpeg" => "JPEG image".to_string(),
            "png" => "PNG image".to_string(),
            "zip" => "ZIP archive".to_string(),
            _ => format!("{} file", ext_lower.to_uppercase()),
        }
    } else {
        "Unknown file type".to_string()
    }
}
----------------------------------------------------

/Users/penrose/dev/D/context-file-concat/src/main.rs
----------------------------------------------------
use eframe::egui;

mod app;
mod core;
mod config;
mod utils;

use app::ContextFileConcatApp;

fn main() -> Result<(), eframe::Error> {
    // Initialize logging
    tracing_subscriber::fmt::init();

    let options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default()
            .with_inner_size([1200.0, 800.0])
            .with_min_inner_size([800.0, 600.0]),
        ..Default::default()
    };

    eframe::run_native(
        "ContextFileConcat",
        options,
        Box::new(|cc| {
            // Use dark theme by default to match macOS
            cc.egui_ctx.set_visuals(egui::Visuals::dark());
            
            Ok(Box::new(ContextFileConcatApp::new(cc)))
        }),
    )
}
----------------------------------------------------

/Users/penrose/dev/D/context-file-concat/src/config/settings.rs
----------------------------------------------------
use std::path::PathBuf;
use std::fs;
use anyhow::Result;
use directories::ProjectDirs;

use super::AppConfig;

const APP_NAME: &str = "ContextFileConcat";
const CONFIG_FILE: &str = "config.json";

pub fn get_config_directory() -> Option<PathBuf> {
    ProjectDirs::from("com", "contextfileconcat", APP_NAME)
        .map(|proj_dirs| proj_dirs.config_dir().to_path_buf())
}

pub fn get_config_file_path() -> Option<PathBuf> {
    get_config_directory().map(|dir| dir.join(CONFIG_FILE))
}

pub fn load_config() -> Result<AppConfig> {
    let config_path = get_config_file_path()
        .ok_or_else(|| anyhow::anyhow!("Could not determine config directory"))?;
    
    if !config_path.exists() {
        tracing::info!("Config file not found, creating default config at {:?}", config_path);
        let default_config = AppConfig::default();
        save_config(&default_config)?;
        return Ok(default_config);
    }
    
    let config_content = fs::read_to_string(&config_path)?;
    let config: AppConfig = serde_json::from_str(&config_content)?;
    
    tracing::info!("Loaded config from {:?}", config_path);
    Ok(config)
}

pub fn save_config(config: &AppConfig) -> Result<()> {
    let config_dir = get_config_directory()
        .ok_or_else(|| anyhow::anyhow!("Could not determine config directory"))?;
    
    // Create config directory if it doesn't exist
    if !config_dir.exists() {
        fs::create_dir_all(&config_dir)?;
        tracing::info!("Created config directory: {:?}", config_dir);
    }
    
    let config_path = config_dir.join(CONFIG_FILE);
    let config_json = serde_json::to_string_pretty(config)?;
    
    fs::write(&config_path, config_json)?;
    tracing::info!("Saved config to {:?}", config_path);
    
    Ok(())
}

pub fn export_config(config: &AppConfig, export_path: &PathBuf) -> Result<()> {
    let config_json = serde_json::to_string_pretty(config)?;
    fs::write(export_path, config_json)?;
    tracing::info!("Exported config to {:?}", export_path);
    Ok(())
}

pub fn import_config(import_path: &PathBuf) -> Result<AppConfig> {
    let config_content = fs::read_to_string(import_path)?;
    let config: AppConfig = serde_json::from_str(&config_content)?;
    tracing::info!("Imported config from {:?}", import_path);
    Ok(config)
}

// Platform-specific paths for reference:
// macOS:    ~/Library/Application Support/ContextFileConcat/
// Linux:    ~/.config/ContextFileConcat/
// Windows:  %APPDATA%/ContextFileConcat/
----------------------------------------------------

/Users/penrose/dev/D/context-file-concat/src/app/mod.rs
----------------------------------------------------
pub mod main_window;

use eframe::egui;
use std::collections::HashSet;
use std::path::PathBuf;
use tokio::sync::{mpsc, Mutex};
use std::sync::Arc;

use crate::core::{FileItem, ScanProgress};
use crate::config::AppConfig;

pub struct ContextFileConcatApp {
    // UI State
    current_path: String,
    selected_files: HashSet<PathBuf>,
    file_tree: Vec<FileItem>,
    filtered_files: Vec<FileItem>,
    expanded_dirs: HashSet<PathBuf>,  // Track which directories are expanded
    
    // Search and Filter
    search_query: String,
    file_extension_filter: String,
    search_in_files_query: String,  // New: Search inside file content
    case_sensitive: bool,
    show_binary_files: bool,
    
    // Input field states
    new_ignore_pattern: String,
    new_tree_pattern: String,
    
    // Progress
    scan_progress: Option<ScanProgress>,
    is_scanning: bool,
    is_searching_content: bool,  // New: Track content search progress
    
    // Config
    config: AppConfig,
    
    // Output settings
    output_path: String,
    output_filename: String,
    include_tree: bool,
    tree_full_mode: bool,  // New: Full tree vs selected files only
    tree_ignore_patterns: HashSet<String>,  // New: Separate ignore patterns for tree
    
    // File preview
    preview_content: String,
    preview_file: Option<PathBuf>,
    
    // Layout state
    file_list_height: f32,  // New: Manual height control
    
    // Search highlighting
    highlighted_preview_content: Vec<PreviewSegment>,  // New: For search highlighting

    // Large files warning
    large_files_count: usize,  // NEW: Track files skipped due to size
    large_files_names: Vec<String>,  // NEW: Names of skipped files
    show_large_files_warning: bool,  // NEW: Show warning popup

    // Async communication
    progress_receiver: Option<Arc<Mutex<mpsc::UnboundedReceiver<ScanProgress>>>>,
    file_receiver: Option<Arc<Mutex<mpsc::UnboundedReceiver<(Vec<FileItem>, usize, Vec<String>)>>>>,
    content_search_receiver: Option<Arc<Mutex<mpsc::UnboundedReceiver<Vec<FileItem>>>>>,
}

// New: For search highlighting in preview
#[derive(Clone, Debug)]
pub struct PreviewSegment {
    pub text: String,
    pub is_match: bool,
}

impl ContextFileConcatApp {
    pub fn new(_cc: &eframe::CreationContext<'_>) -> Self {
        let config = AppConfig::load().unwrap_or_default();
        
        let output_filename = format!(
            "output_{}.txt", 
            chrono::Local::now().format("%Y%m%d_%H%M%S")
        );
        
        Self {
            current_path: String::new(),
            selected_files: HashSet::new(),
            file_tree: Vec::new(),
            filtered_files: Vec::new(),
            expanded_dirs: HashSet::new(),
            search_query: String::new(),
            file_extension_filter: String::new(),
            search_in_files_query: String::new(),
            case_sensitive: false,
            show_binary_files: true,
            new_ignore_pattern: String::new(),
            new_tree_pattern: String::new(),
            scan_progress: None,
            is_scanning: false,
            is_searching_content: false,
            config,
            output_path: dirs::desktop_dir()
                .unwrap_or_else(|| dirs::home_dir().unwrap_or_default())
                .to_string_lossy()
                .to_string(),
            output_filename,
            include_tree: false,
            tree_full_mode: false,
            tree_ignore_patterns: HashSet::new(),
            preview_content: String::new(),
            preview_file: None,
            file_list_height: 400.0,  // New: Default height
            highlighted_preview_content: Vec::new(),  // New
            large_files_count: 0,  // NEW
            large_files_names: Vec::new(),  // NEW
            show_large_files_warning: false,  // NEW
            progress_receiver: None,
            file_receiver: None,
            content_search_receiver: None,
        }
    }
}

impl eframe::App for ContextFileConcatApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        self.update_progress();
        
        egui::CentralPanel::default().show(ctx, |ui| {
            self.render_main_ui(ui, ctx);
        });
        
        // Request repaint for smooth progress updates
        if self.is_scanning {
            ctx.request_repaint();
        }
    }
    
    fn save(&mut self, storage: &mut dyn eframe::Storage) {
        // Save app state
        if let Ok(config_json) = serde_json::to_string(&self.config) {
            storage.set_string("app_config", config_json);
        }
    }
}
----------------------------------------------------

/Users/penrose/dev/D/context-file-concat/src/app/main_window.rs
----------------------------------------------------
use eframe::egui;
use std::path::PathBuf;
use std::collections::HashSet;
use tokio::sync::mpsc;
use std::sync::Arc;

use super::{ContextFileConcatApp, PreviewSegment};
use crate::core::{DirectoryScanner, FileHandler, SearchEngine, TreeGenerator, SearchFilter, FileItem};
use crate::utils::file_detection::is_image_file;

impl ContextFileConcatApp {
    pub fn render_main_ui(&mut self, _ui: &mut egui::Ui, ctx: &egui::Context) {
        // Top toolbar panel
        egui::TopBottomPanel::top("toolbar")
            .default_height(60.0)
            .show(ctx, |ui| {
                self.render_toolbar(ui);
            });
        
        // Bottom panel for output settings
        egui::TopBottomPanel::bottom("output_panel")
            .default_height(60.0)
            .show(ctx, |ui| {
                self.render_bottom_panel(ui);
            });
        
        // Left side panel for search and filters
        egui::SidePanel::left("left_panel")
            .default_width(300.0)
            .min_width(250.0)
            .show(ctx, |ui| {
                self.render_left_panel(ui);
            });
        
        // Central panel for file list and preview - FIXED LAYOUT
        egui::CentralPanel::default().show(ctx, |ui| {
            self.render_right_panel_fixed(ui);
        });
        
        // Progress overlay
        if self.is_scanning {
            self.render_progress_overlay(ctx);
        }

        // Large files warning
        if self.show_large_files_warning {
            self.render_large_files_warning(ctx);
        }
    }
    
    fn render_toolbar(&mut self, ui: &mut egui::Ui) {
        ui.label("📁 Root Directory:");
        
        if ui.button("Select Directory").clicked() {
            if let Some(path) = rfd::FileDialog::new().pick_folder() {
                self.current_path = path.to_string_lossy().to_string();
                self.start_directory_scan();
            }
        }
        ui.add_space(1.0);
        ui.add(
            egui::TextEdit::singleline(&mut self.current_path)
                .desired_width(400.0)
                .hint_text("Enter directory path or use Select Directory button")
        );
        ui.add_space(1.0);
        if ui.button("Scan").clicked() && !self.current_path.is_empty() {
            self.start_directory_scan();
        }
        
        ui.separator();
        
        // Config buttons
        if ui.button("💾 Export Config").clicked() {
            self.save_config_dialog();
        }
        ui.add_space(1.0);
        if ui.button("📂 Import Config").clicked() {
            self.load_config_dialog();
        }
        ui.add_space(1.0);
    }
    
    fn render_left_panel(&mut self, ui: &mut egui::Ui) {
        ui.vertical(|ui| {
            ui.heading("🔍 Search & Filter");
            
            // Search input
            ui.horizontal(|ui| {
                ui.label("Search:");
                if ui.add(
                    egui::TextEdit::singleline(&mut self.search_query)
                        .hint_text("Search in filenames...")
                ).changed() {
                    self.apply_filters();
                }
            });
            
            // File extension filter
            ui.horizontal(|ui| {
                ui.label("Extension:");
                if ui.add(
                    egui::TextEdit::singleline(&mut self.file_extension_filter)
                        .hint_text("e.g., .rs, .js, .py")
                ).changed() {
                    self.apply_filters();
                }
            });
            
            ui.separator();
            
            // Search in files content
            ui.heading("🔍 Search in Files");
            ui.horizontal(|ui| {
                ui.label("Content:");
                if ui.add(
                    egui::TextEdit::singleline(&mut self.search_in_files_query)
                        .hint_text("Search text inside files...")
                ).changed() {
                    if !self.search_in_files_query.is_empty() {
                        self.start_content_search();
                    } else {
                        self.apply_filters(); // Reset to normal filtering
                    }
                    // Update preview highlighting when search changes
                    self.update_preview_highlighting();
                }
            });
            
            if self.is_searching_content {
                ui.horizontal(|ui| {
                    ui.spinner();
                    ui.label("Searching in files...");
                });
            }
            
            // Filter options
            ui.horizontal(|ui| {
                if ui.checkbox(&mut self.case_sensitive, "Case sensitive").changed() {
                    self.apply_filters();
                    self.update_preview_highlighting();
                }
                if ui.checkbox(&mut self.show_binary_files, "Show binary files").changed() {
                    self.apply_filters();
                }
            });
            
            ui.separator();

            // Ignore patterns
            ui.heading("🚫 Ignore Patterns");

            // Remove empty directories option
            if ui.checkbox(&mut self.config.remove_empty_directories, "Remove empty directories").changed() {
                self.apply_filters();
            }

            ui.label("Common patterns:");

            ui.horizontal_wrapped(|ui| {
                let common_patterns = [
                    "node_modules/", "target/", ".git/", "*.log", 
                    "*.tmp", ".DS_Store", "Thumbs.db", "*.class"
                ];
                
                for pattern in common_patterns {
                    if ui.small_button(pattern).clicked() {
                        self.config.ignore_patterns.insert(pattern.to_string());
                        self.apply_filters();
                    }
                }
            });
            ui.add_space(1.0);
            // Custom ignore pattern input
            ui.horizontal(|ui| {
                ui.add(
                    egui::TextEdit::singleline(&mut self.new_ignore_pattern)
                        .hint_text("Add pattern (wildcards: *, ?)")
                );
                if ui.button("Add").clicked() && !self.new_ignore_pattern.is_empty() {
                    self.config.ignore_patterns.insert(self.new_ignore_pattern.clone());
                    self.new_ignore_pattern.clear();
                    self.apply_filters();
                }
            });
            
            // List current ignore patterns
            ui.collapsing("Current ignore patterns", |ui| {
                // Make it scrollable and take available height (ensure minimum height)
                let available_height = (ui.available_height() - 20.0).max(50.0); // Minimum 50px
                egui::ScrollArea::vertical()
                    .max_height(available_height)
                    .auto_shrink([false, false])
                    .show(ui, |ui| {
                        let patterns: Vec<String> = self.config.ignore_patterns.iter().cloned().collect();
                        for pattern in patterns {
                            ui.horizontal(|ui| {
                                if ui.small_button("❌").clicked() {
                                    self.config.ignore_patterns.remove(&pattern);
                                    self.apply_filters();
                                }
                                ui.label(&pattern);
                            });
                        }
                    });
            });
        });
    }
    
    // FIXED: Stable resizable layout with egui 0.29 compatibility
    fn render_right_panel_fixed(&mut self, ui: &mut egui::Ui) {
        let available_height = ui.available_height();
        let min_file_list_height = 150.0;
        let min_preview_height = 100.0;
        
        // Ensure file_list_height is within bounds
        self.file_list_height = self.file_list_height
            .max(min_file_list_height)
            .min((available_height - min_preview_height).max(min_file_list_height));
        
        ui.vertical(|ui| {
            // File list section - FIXED: Simpler approach
            ui.allocate_ui_with_layout(
                egui::Vec2::new(ui.available_width(), self.file_list_height),
                egui::Layout::top_down(egui::Align::LEFT),
                |ui| {
                    ui.group(|ui| {
                        ui.set_height((self.file_list_height - 8.0).max(50.0));
                        self.render_file_list(ui);
                    });
                }
            );
            
            // Resizer with cursor change
            let resizer_response = ui.allocate_response(
                egui::Vec2::new(ui.available_width(), 1.0),
                egui::Sense::drag()
            );

            if resizer_response.dragged() {
                self.file_list_height += resizer_response.drag_delta().y;
            }

            // Change cursor when hovering over resizer
            if resizer_response.hovered() {
                ui.ctx().set_cursor_icon(egui::CursorIcon::ResizeVertical);
            }

            // Draw resizer
            ui.painter().rect_filled(
                resizer_response.rect,
                egui::Rounding::ZERO,
                if resizer_response.hovered() {
                    egui::Color32::from_gray(100)
                } else {
                    egui::Color32::from_gray(80)
                },
            );
            
            // Preview section
            ui.group(|ui| {
                ui.set_height((ui.available_height() - 8.0).max(50.0)); // Account for group padding
                self.render_file_preview_with_highlighting(ui);
            });
        });
    }
    
    fn render_file_list(&mut self, ui: &mut egui::Ui) {
        ui.heading("📄 Files");
        
        ui.horizontal(|ui| {
            if ui.button("Select All").clicked() {
                self.select_all_files();
            }
            if ui.button("Deselect All").clicked() {
                self.selected_files.clear();
            }
            if ui.button("Expand All").clicked() {
                self.expand_all_directories();
            }
            if ui.button("Collapse All").clicked() {
                self.expanded_dirs.clear();
            }
            
            ui.separator();
            ui.label(format!("{} files found, {} selected", 
                self.filtered_files.len(), 
                self.selected_files.len()
            ));
        });
        
        ui.separator();
        
        // FIXED: Use id_salt instead of deprecated id_source
        egui::ScrollArea::vertical()
            .auto_shrink([false, false])
            .id_salt("file_tree_scroll")
            .show(ui, |ui| {
                self.render_file_tree_recursive(ui);
            });
    }
    
    fn render_file_tree_recursive(&mut self, ui: &mut egui::Ui) {
        // Kleinerer horizontaler Abstand
        ui.spacing_mut().item_spacing.x = 2.0;
        // Build a hierarchical structure from flat file list
        let mut root_items = Vec::new();
        let current_root = PathBuf::from(&self.current_path);
        
        // Find direct children of the current root
        for item in &self.filtered_files {
            if let Ok(relative) = item.path.strip_prefix(&current_root) {
                if relative.components().count() == 1 {
                    root_items.push(item.clone());
                }
            }
        }
        
        // Sort: directories first, then files
        root_items.sort_by(|a, b| {
            match (a.is_directory, b.is_directory) {
                (true, false) => std::cmp::Ordering::Less,
                (false, true) => std::cmp::Ordering::Greater,
                _ => a.path.file_name().cmp(&b.path.file_name()),
            }
        });
        
        // Render each root item
        for item in root_items {
            self.render_tree_item(ui, &item, 0);
        }
    }
    
    fn render_tree_item(&mut self, ui: &mut egui::Ui, item: &FileItem, indent_level: usize) {
        // Check if this item matches the search
        let is_search_match = self.is_search_match(item);
        
        ui.horizontal(|ui| {
            // Indentation
            ui.add_space(indent_level as f32 * 35.0);
            
            if item.is_directory {
                // Expand/collapse button for directories
                let is_expanded = self.expanded_dirs.contains(&item.path);
                
                // Use the same arrow symbols as collapsing headers
                let expand_response = ui.add(
                    egui::Button::new(if is_expanded { "🔽" } else { "▶" })
                        .small()
                        .frame(false)
                );
                
                if expand_response.clicked() {
                    if is_expanded {
                        self.expanded_dirs.remove(&item.path);
                    } else {
                        self.expanded_dirs.insert(item.path.clone());
                    }
                }
                
                // Directory checkbox
                let mut dir_selected = self.is_directory_selected(&item.path);
                let mut should_toggle = false;

                if ui.checkbox(&mut dir_selected.0, "").changed() {
                    should_toggle = true;
                }

                if should_toggle {
                    self.toggle_directory_selection(&item.path);
                }

                // Directory icon and name with search highlighting and selection styling
                let dir_selected = self.is_directory_selected(&item.path).0;

                if dir_selected {
                    ui.label("📁");
                } else {
                    ui.colored_label(egui::Color32::from_gray(120), "📁");
                }

                let dir_name = item.path.file_name().unwrap_or_default().to_string_lossy();
                if is_search_match {
                    ui.colored_label(egui::Color32::YELLOW, format!("🔍 {}", dir_name));
                } else if dir_selected {
                    ui.colored_label(egui::Color32::WHITE, dir_name.as_ref());
                } else {
                    ui.colored_label(egui::Color32::from_gray(160), dir_name.as_ref());
                }

                // Small "i" button to add directory to ignore patterns (NACH dem Namen)
                let ignore_button = ui.add(
                    egui::Button::new("i")
                        .small()
                        .min_size(egui::Vec2::new(16.0, 16.0))
                        .fill(egui::Color32::from_gray(30)) // Noch dunkler
                );

                if ignore_button.clicked() {
                    if let Some(dir_name) = item.path.file_name().and_then(|n| n.to_str()) {
                        // Add with trailing slash to indicate directory
                        self.config.ignore_patterns.insert(format!("{}/", dir_name));
                        self.apply_filters();
                    }
                }

                if ignore_button.hovered() {
                    egui::show_tooltip_at_pointer(
                        ui.ctx(), 
                        egui::LayerId::new(egui::Order::Tooltip, egui::Id::new("ignore_dir_tooltip")), 
                        egui::Id::new("ignore_dir_tooltip"),
                        |ui: &mut egui::Ui| {
                            ui.label("Add directory to ignore patterns");
                        }
                    );
                }
            } else {
                // File checkbox
                let mut is_selected = self.selected_files.contains(&item.path);
                if ui.checkbox(&mut is_selected, "").changed() {
                    if is_selected {
                        self.selected_files.insert(item.path.clone());
                    } else {
                        self.selected_files.remove(&item.path);
                    }
                }
                
                // File icon with selection styling
                let icon = if is_image_file(&item.path) {
                    "📷"
                } else if item.is_binary {
                    "🔧"
                } else {
                    "📄"
                };
                
                // Apply selection styling to icon
                if is_selected {
                    ui.label(icon);
                } else {
                    ui.colored_label(egui::Color32::from_gray(120), icon);
                }
                
                // File name (clickable for preview) with search highlighting and selection styling
                let name = item.path.file_name().unwrap_or_default().to_string_lossy();
                let label_text = if is_search_match {
                    format!("🔍 {}", name)
                } else {
                    name.to_string()
                };
                
                let response = if is_search_match {
                    ui.selectable_label(
                        self.preview_file.as_ref() == Some(&item.path),
                        egui::RichText::new(label_text).color(egui::Color32::YELLOW)
                    )
                } else if is_selected {
                    // Selected files are brighter/more prominent
                    ui.selectable_label(
                        self.preview_file.as_ref() == Some(&item.path),
                        egui::RichText::new(label_text).color(egui::Color32::WHITE)
                    )
                } else {
                    // Unselected files are grayed out
                    ui.selectable_label(
                        self.preview_file.as_ref() == Some(&item.path),
                        egui::RichText::new(label_text).color(egui::Color32::from_gray(160))
                    )
                };
                
                if response.clicked() {
                    self.load_file_preview(&item.path);
                }
                
                // Small "i" button to add to ignore patterns (NACH dem Namen)
                let ignore_button = ui.add(
                    egui::Button::new("i")
                        .small()
                        .min_size(egui::Vec2::new(16.0, 16.0))
                        .fill(egui::Color32::from_gray(30)) // Noch dunkler
                );
                
                if ignore_button.clicked() {
                    if let Some(file_name) = item.path.file_name().and_then(|n| n.to_str()) {
                        self.config.ignore_patterns.insert(file_name.to_string());
                        self.apply_filters();
                    }
                }
                
                if ignore_button.hovered() {
                    egui::show_tooltip_at_pointer(
                        ui.ctx(), 
                        egui::LayerId::new(egui::Order::Tooltip, egui::Id::new("ignore_tooltip")), 
                        egui::Id::new("ignore_tooltip"),
                        |ui: &mut egui::Ui| {
                            ui.label("Add to ignore patterns");
                        }
                    );
                }
                
                // File size with padding and selection styling
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    ui.add_space(20.0); // Space for scrollbar
                    if is_selected {
                        ui.label(format_file_size(item.size));
                    } else {
                        ui.colored_label(egui::Color32::from_gray(120), format_file_size(item.size));
                    }
                });
            }
        });
        
        // Render children if directory is expanded
        if item.is_directory && self.expanded_dirs.contains(&item.path) {
            let children = self.get_directory_children(&item.path);
            for child in children {
                self.render_tree_item(ui, &child, indent_level + 1);
            }
        }
    }
    
    fn is_search_match(&self, item: &FileItem) -> bool {
        // Check filename search
        let filename_match = if !self.search_query.is_empty() {
            let file_name = item.path.file_name()
                .and_then(|name| name.to_str())
                .unwrap_or("");
            
            if self.case_sensitive {
                file_name.contains(&self.search_query)
            } else {
                let query_lower = self.search_query.to_lowercase();
                file_name.to_lowercase().contains(&query_lower)
            }
        } else {
            false
        };
        
        // Check content search (only if we're actively searching content and this file is in results)
        let content_match = if !self.search_in_files_query.is_empty() && !item.is_directory {
            // This will be true if the file is currently displayed due to content search
            !self.search_query.is_empty() || self.is_searching_content
        } else {
            false
        };
        
        filename_match || content_match
    }
    
    fn get_directory_children(&self, dir_path: &PathBuf) -> Vec<FileItem> {
        let mut children = Vec::new();
        
        // Only get children that are ACTUALLY in the filtered_files list
        for item in &self.filtered_files {
            if let Some(parent) = item.path.parent() {
                if parent == dir_path {
                    children.push(item.clone());
                }
            }
        }
        
        // Sort: directories first, then files
        children.sort_by(|a, b| {
            match (a.is_directory, b.is_directory) {
                (true, false) => std::cmp::Ordering::Less,
                (false, true) => std::cmp::Ordering::Greater,
                _ => a.path.file_name().cmp(&b.path.file_name()),
            }
        });
        
        children
    }
    
    fn is_directory_selected(&self, dir_path: &PathBuf) -> (bool, bool) {
        let children = self.get_all_files_in_directory(dir_path);
        if children.is_empty() {
            return (false, false);
        }
        
        let selected_count = children.iter()
            .filter(|path| self.selected_files.contains(*path))
            .count();
            
        if selected_count == 0 {
            (false, false) // None selected
        } else if selected_count == children.len() {
            (true, false) // All selected
        } else {
            (true, true) // Partially selected (indeterminate)
        }
    }
    
    fn get_all_files_in_directory(&self, dir_path: &PathBuf) -> Vec<PathBuf> {
        let mut files = Vec::new();
        
        for item in &self.filtered_files {
            if !item.is_directory && item.path.starts_with(dir_path) {
                files.push(item.path.clone());
            }
        }
        
        files
    }
    
    fn toggle_directory_selection(&mut self, dir_path: &PathBuf) {
        let files_in_dir = self.get_all_files_in_directory(dir_path);
        let (is_selected, _) = self.is_directory_selected(dir_path);
        
        if is_selected {
            // Deselect all files in directory
            for file_path in files_in_dir {
                self.selected_files.remove(&file_path);
            }
        } else {
            // Select all files in directory
            for file_path in files_in_dir {
                self.selected_files.insert(file_path);
            }
        }
    }
    
    fn expand_all_directories(&mut self) {
        for item in &self.filtered_files {
            if item.is_directory {
                self.expanded_dirs.insert(item.path.clone());
            }
        }
    }
    
    // NEW: Enhanced preview with search highlighting
    fn render_file_preview_with_highlighting(&mut self, ui: &mut egui::Ui) {
        ui.heading("Preview");
        
        if let Some(preview_file) = &self.preview_file {
            ui.label(format!("📄 {}", preview_file.file_name().unwrap_or_default().to_string_lossy()));
            ui.separator();
            
            // FIXED: Use id_salt instead of deprecated id_source
            egui::ScrollArea::vertical()
                .auto_shrink([false, false])
                .stick_to_bottom(false)
                .id_salt("preview_scroll")
                .show(ui, |ui| {
                    if !self.search_in_files_query.is_empty() && !self.highlighted_preview_content.is_empty() {
                        // Render highlighted content
                        ui.horizontal_wrapped(|ui| {
                            for segment in &self.highlighted_preview_content {
                                if segment.is_match {
                                    ui.colored_label(egui::Color32::YELLOW, &segment.text);
                                } else {
                                    ui.label(&segment.text);
                                }
                            }
                        });
                    } else {
                        // Render normal content
                        ui.add(
                            egui::TextEdit::multiline(&mut self.preview_content)
                                .code_editor()
                                .desired_width(f32::INFINITY)
                                .desired_rows(50)
                        );
                    }
                });
        } else {
            ui.centered_and_justified(|ui| {
                ui.label("Select a file to preview");
            });
        }
    }
    
    // NEW: Update preview highlighting
    fn update_preview_highlighting(&mut self) {
        if self.search_in_files_query.is_empty() || self.preview_content.is_empty() {
            self.highlighted_preview_content.clear();
            return;
        }
        
        let search_term = if self.case_sensitive {
            self.search_in_files_query.clone()
        } else {
            self.search_in_files_query.to_lowercase()
        };
        
        let content = if self.case_sensitive {
            self.preview_content.clone()
        } else {
            self.preview_content.to_lowercase()
        };
        
        let mut segments = Vec::new();
        let mut last_end = 0;
        
        // Find all matches
        for match_start in content.match_indices(&search_term).map(|(i, _)| i) {
            // Add text before match
            if match_start > last_end {
                segments.push(PreviewSegment {
                    text: self.preview_content[last_end..match_start].to_string(),
                    is_match: false,
                });
            }
            
            // Add match
            let match_end = match_start + search_term.len();
            segments.push(PreviewSegment {
                text: self.preview_content[match_start..match_end].to_string(),
                is_match: true,
            });
            
            last_end = match_end;
        }
        
        // Add remaining text
        if last_end < self.preview_content.len() {
            segments.push(PreviewSegment {
                text: self.preview_content[last_end..].to_string(),
                is_match: false,
            });
        }
        
        self.highlighted_preview_content = segments;
    }
    
    fn render_bottom_panel(&mut self, ui: &mut egui::Ui) {
        ui.vertical(|ui| {
            // Erste Zeile: Überschrift
            ui.horizontal(|ui| {
                ui.heading("📤 Output Settings");
            });
            
            ui.separator();
            
            // Zweite Zeile: Output Directory
            ui.horizontal(|ui| {
                ui.label("Output Directory:");
                ui.add_space(120.0 - ui.fonts(|f| f.layout_no_wrap("Output Directory:".to_string(), egui::FontId::default(), egui::Color32::WHITE)).size().x);
                ui.add(
                    egui::TextEdit::singleline(&mut self.output_path)
                        .desired_width(300.0)
                );
                
                if ui.button("Browse").clicked() {
                    if let Some(path) = rfd::FileDialog::new().pick_folder() {
                        self.output_path = path.to_string_lossy().to_string();
                    }
                }
            });

            // Dritte Zeile: Filename
            ui.horizontal(|ui| {
                ui.label("Filename:");
                ui.add_space(120.0 - ui.fonts(|f| f.layout_no_wrap("Filename:".to_string(), egui::FontId::default(), egui::Color32::WHITE)).size().x - 5.0);
                ui.add(
                    egui::TextEdit::singleline(&mut self.output_filename)
                        .desired_width(300.0)
                );
            });
            
            // Vierte Zeile: Tree options
            ui.horizontal(|ui| {
                ui.checkbox(&mut self.include_tree, "Include directory tree");
                
                if self.include_tree {
                    if ui.checkbox(&mut self.tree_full_mode, "Full tree mode").changed() {
                        if !self.tree_full_mode {
                            self.tree_ignore_patterns.clear();
                        }
                    }
                }
            });
            
            // Fünfte Zeile: Tree ignore patterns (falls needed)
            if self.include_tree && self.tree_full_mode {
                ui.horizontal(|ui| {
                    ui.label("Tree ignore patterns:");
                    ui.add(
                        egui::TextEdit::singleline(&mut self.new_tree_pattern)
                            .hint_text("Add tree ignore pattern...")
                            .desired_width(150.0)
                    );
                    if ui.button("Add").clicked() && !self.new_tree_pattern.is_empty() {
                        self.tree_ignore_patterns.insert(self.new_tree_pattern.clone());
                        self.new_tree_pattern.clear();
                    }
                });
                
                // Show current tree ignore patterns
                if !self.tree_ignore_patterns.is_empty() {
                    ui.horizontal_wrapped(|ui| {
                        let patterns: Vec<String> = self.tree_ignore_patterns.iter().cloned().collect();
                        for pattern in patterns {
                            ui.horizontal(|ui| {
                                ui.label(&pattern);
                                if ui.small_button("❌").clicked() {
                                    self.tree_ignore_patterns.remove(&pattern);
                                }
                            });
                        }
                    });
                }
            }
            
            ui.separator();
            
            // Letzte Zeile: Generate Button (zentriert)
            ui.horizontal(|ui| {
                let can_generate = !self.selected_files.is_empty() && !self.is_scanning;
                
                ui.add_space(ui.available_width() / 2.0 - 50.0); // Zentrieren
                
                let button_response = ui.scope(|ui| {
                    if can_generate {
                        // Ändere Button-Stil für aktiven Zustand
                        ui.style_mut().visuals.widgets.inactive.weak_bg_fill = egui::Color32::from_rgb(98, 197, 85);
                        ui.style_mut().visuals.widgets.inactive.fg_stroke.color = egui::Color32::from_rgb(27, 27, 27);
                        ui.style_mut().visuals.widgets.hovered.weak_bg_fill = egui::Color32::from_rgb(93, 185, 82);
                        ui.style_mut().visuals.widgets.hovered.fg_stroke.color = egui::Color32::from_rgb(27, 27, 27);
                    }
                    
                    ui.add_enabled(can_generate, 
                        egui::Button::new("🚀 Generate").min_size(egui::Vec2::new(100.0, 30.0))
                    )
                }).inner;

                if button_response.clicked() {
                    self.generate_output();
                }
            });
            ui.add_space(1.0);
        });
    }
}

fn format_file_size(size: u64) -> String {
    const UNITS: &[&str] = &["B", "KB", "MB", "GB"];
    let mut size = size as f64;
    let mut unit_index = 0;
    
    while size >= 1024.0 && unit_index < UNITS.len() - 1 {
        size /= 1024.0;
        unit_index += 1;
    }
    
    if unit_index == 0 {
        format!("{} {}", size as u64, UNITS[unit_index])
    } else {
        format!("{:.1} {}", size, UNITS[unit_index])
    }
}

fn format_number_with_separators(number: usize) -> String {
    let number_str = number.to_string();
    let chars: Vec<char> = number_str.chars().collect();
    let mut result = String::new();
    
    for (i, &ch) in chars.iter().enumerate() {
        if i > 0 && (chars.len() - i) % 3 == 0 {
            result.push('\'');
        }
        result.push(ch);
    }
    
    result
}    

// Additional implementation methods
impl ContextFileConcatApp {
    pub fn start_directory_scan(&mut self) {
        if self.current_path.is_empty() || self.is_scanning {
            return;
        }
        
        self.is_scanning = true;
        self.scan_progress = None;
        self.file_tree.clear();
        self.filtered_files.clear();
        
        let (progress_sender, progress_receiver) = mpsc::unbounded_channel();
        let (file_sender, file_receiver) = mpsc::unbounded_channel::<(Vec<FileItem>, usize, Vec<String>)>();
        
        self.progress_receiver = Some(Arc::new(tokio::sync::Mutex::new(progress_receiver)));
        
        let path = PathBuf::from(&self.current_path);
        let ignore_patterns = self.config.ignore_patterns.clone();
        
        // Store the file receiver to get scan results
        let file_receiver = Arc::new(tokio::sync::Mutex::new(file_receiver));
        
        // Spawn async scanning task
        std::thread::spawn(move || {
            let rt = tokio::runtime::Runtime::new().unwrap();
            rt.block_on(async move {
                let scanner = DirectoryScanner::new(ignore_patterns);
                
                match scanner.scan_directory(&path, progress_sender).await {
                    Ok((files, large_files_count, large_files_names)) => {
                        // Send files, count, and names through the channel
                        let _ = file_sender.send((files, large_files_count, large_files_names));
                        tracing::info!("Scan completed with {} large files skipped", large_files_count);
                    }
                    Err(e) => {
                        tracing::error!("Scan failed: {}", e);
                    }
                }
            });
        });
        
        // Store the file receiver for later retrieval
        self.file_receiver = Some(file_receiver);
    }
    
    pub fn update_progress(&mut self) {
        let mut should_stop_scanning = false;
        let mut progress_update = None;
        let mut new_files = None;
        let mut content_search_results = None;
        
        // Check for progress updates
        if let Some(receiver) = &self.progress_receiver {
            if let Ok(mut rx) = receiver.try_lock() {
                while let Ok(progress) = rx.try_recv() {
                    progress_update = Some(progress.clone());
                    
                    // If scan is complete, update file list
                    if progress.processed >= progress.total && progress.status.contains("complete") {
                        should_stop_scanning = true;
                    }
                }
            }
        }
        
        // Check for file updates
        if let Some(file_receiver) = &self.file_receiver {
            if let Ok(mut rx) = file_receiver.try_lock() {
                if let Ok((files, large_files_count, large_files_names)) = rx.try_recv() {
                    new_files = Some(files);
                    if large_files_count > 0 {
                        self.large_files_count = large_files_count;
                        self.large_files_names = large_files_names;
                        self.show_large_files_warning = true;
                    }
                }
            }
        }
        
        // Check for content search results
        if let Some(content_receiver) = &self.content_search_receiver {
            if let Ok(mut rx) = content_receiver.try_lock() {
                if let Ok(results) = rx.try_recv() {
                    content_search_results = Some(results);
                    self.is_searching_content = false;
                }
            }
        }
        
        if let Some(progress) = progress_update {
            self.scan_progress = Some(progress);
        }
        
        if let Some(files) = new_files {
            self.file_tree = files;
            
            // Check if there might be large files and show warning
            // This is a simple heuristic - we could make it more sophisticated
            if !self.current_path.is_empty() {
                // For now, just a placeholder - you could implement proper large file counting
                // self.large_files_count = count_large_files(&self.current_path);
                // self.show_large_files_warning = self.large_files_count > 0;
            }
        }
        
        if let Some(search_results) = content_search_results {
            // Add parent directories to make tree view work
            let mut results_with_parents = search_results.clone();
            let root_path = PathBuf::from(&self.current_path);
            
            for item in &search_results {
                let mut current = item.path.parent();
                while let Some(parent) = current {
                    if parent >= root_path {
                        if let Some(dir_item) = self.file_tree.iter().find(|i| i.path == parent && i.is_directory) {
                            if !results_with_parents.iter().any(|r| r.path == parent) {
                                results_with_parents.push(dir_item.clone());
                            }
                        }
                    }
                    current = parent.parent();
                }
            }
            
            self.filtered_files = results_with_parents;
        }
        
        if should_stop_scanning {
            self.is_scanning = false;
            self.apply_filters();
        }
    }
    
    pub fn apply_filters(&mut self) {
        let filter = SearchFilter {
            query: self.search_query.clone(),
            extension: self.file_extension_filter.clone(),
            case_sensitive: self.case_sensitive,
            show_binary: self.show_binary_files,
            ignore_patterns: self.config.ignore_patterns.clone(),
        };
        
        let mut filtered = SearchEngine::filter_files(&self.file_tree, &filter);
        
        // Add parent directories for filtered files to make tree view work
        let mut additional_dirs = HashSet::new();
        let root_path = PathBuf::from(&self.current_path);
        
        for item in &filtered {
            if !item.is_directory {
                // Add all parent directories of this file
                let mut current = item.path.parent();
                while let Some(parent) = current {
                    if parent >= root_path && !additional_dirs.contains(parent) {
                        additional_dirs.insert(parent.to_path_buf());
                    }
                    current = parent.parent();
                }
            }
        }
        
        // Add missing parent directories to filtered list
        for dir_path in additional_dirs {
            // Find the original directory item in file_tree
            if let Some(dir_item) = self.file_tree.iter().find(|item| item.path == dir_path && item.is_directory) {
                // Only add if not already in filtered list
                if !filtered.iter().any(|item| item.path == dir_path) {
                    filtered.push(dir_item.clone());
                }
            }
        }
        
        // Remove empty directories if option is enabled
        if self.config.remove_empty_directories {
            filtered = self.remove_empty_directories(filtered);
        }
        
        self.filtered_files = filtered;
    }

    // NEW: Helper method to remove empty directories
    fn remove_empty_directories(&self, mut files: Vec<FileItem>) -> Vec<FileItem> {
        let mut has_changes = true;
        
        while has_changes {
            has_changes = false;
            let files_before_len = files.len();
            
            // First collect directories to remove
            let mut dirs_to_remove = Vec::new();
            
            for item in &files {
                if item.is_directory {
                    // Check if directory has any files (not just subdirectories)
                    let has_files = files.iter().any(|other| {
                        !other.is_directory && other.path.starts_with(&item.path) && other.path != item.path
                    });
                    
                    if !has_files {
                        dirs_to_remove.push(item.path.clone());
                    }
                }
            }
            
            // Remove empty directories
            files.retain(|item| {
                !dirs_to_remove.contains(&item.path)
            });
            
            if files.len() != files_before_len {
                has_changes = true;
            }
        }
        
        files
    }
    
    pub fn select_all_files(&mut self) {
        for file in &self.filtered_files {
            if !file.is_directory {
                self.selected_files.insert(file.path.clone());
            }
        }
    }
    
    pub fn load_file_preview(&mut self, file_path: &PathBuf) {
        self.preview_file = Some(file_path.clone());
        
        match FileHandler::get_file_preview(file_path, 1000) { // Increased from 20 to 1000 lines
            Ok(content) => {
                self.preview_content = content;
                self.update_preview_highlighting(); // Update highlighting when loading new file
            }
            Err(e) => {
                self.preview_content = format!("Error loading preview: {}", e);
                self.highlighted_preview_content.clear();
            }
        }
    }
    
    pub fn save_current_config(&mut self) {
        if let Err(e) = self.config.save() {
            tracing::error!("Failed to save config: {}", e);
        } else {
            tracing::info!("Config saved successfully");
        }
    }

    pub fn save_config_dialog(&mut self) {
        if let Some(file) = rfd::FileDialog::new()
            .add_filter("JSON Config", &["json"])
            .set_file_name("context-file-concat-config.json")
            .save_file()
        {
            match crate::config::settings::export_config(&self.config, &file) {
                Ok(_) => {
                    tracing::info!("Config exported to {:?}", file);
                }
                Err(e) => {
                    tracing::error!("Failed to export config: {}", e);
                }
            }
        }
    }
    
    pub fn load_config_dialog(&mut self) {
        if let Some(file) = rfd::FileDialog::new()
            .add_filter("JSON Config", &["json"])
            .pick_file()
        {
            match crate::config::settings::import_config(&file) {
                Ok(config) => {
                    self.config = config;
                    // Apply the new config filters immediately
                    self.apply_filters();
                    tracing::info!("Config loaded from {:?}", file);
                }
                Err(e) => {
                    tracing::error!("Failed to load config: {}", e);
                }
            }
        }
    }
    
    pub fn generate_output(&mut self) {
        if self.selected_files.is_empty() || self.is_scanning {
            return;
        }
        
        let output_path = PathBuf::from(&self.output_path).join(&self.output_filename);
        let selected_files: Vec<PathBuf> = self.selected_files.iter().cloned().collect();
        let include_tree = self.include_tree;
        
        // Generate tree if needed
        let tree_content = if include_tree {
            let root_path = PathBuf::from(&self.current_path);
            
            if self.tree_full_mode {
                // Full tree mode with separate ignore patterns
                Some(TreeGenerator::generate_tree(
                    &self.file_tree,
                    &root_path,
                    &self.tree_ignore_patterns
                ))
            } else {
                // Selected files only mode
                let selected_items: Vec<_> = self.file_tree.iter()
                    .filter(|item| {
                        if item.is_directory {
                            // Include directory if any selected file is inside it
                            selected_files.iter().any(|f| f.starts_with(&item.path))
                        } else {
                            // Include file if it's selected
                            selected_files.contains(&item.path)
                        }
                    })
                    .cloned()
                    .collect();
                    
                Some(TreeGenerator::generate_tree(
                    &selected_items,
                    &root_path,
                    &HashSet::new() // No additional ignores for selected files mode
                ))
            }
        } else {
            None
        };
        
        let (progress_sender, progress_receiver) = mpsc::unbounded_channel();
        self.progress_receiver = Some(Arc::new(tokio::sync::Mutex::new(progress_receiver)));
        self.is_scanning = true; // Reuse progress system for generation
        
        // Spawn async generation task
        let rt = tokio::runtime::Runtime::new().unwrap();
        std::thread::spawn(move || {
            rt.block_on(async move {
                match FileHandler::generate_concatenated_file(
                    &selected_files,
                    &output_path,
                    include_tree,
                    tree_content,
                    progress_sender,
                ).await {
                    Ok(_) => {
                        tracing::info!("File generation completed: {}", output_path.display());
                    }
                    Err(e) => {
                        tracing::error!("File generation failed: {}", e);
                    }
                }
            });
        });
    }
    
    pub fn start_content_search(&mut self) {
        if self.search_in_files_query.is_empty() || self.is_searching_content {
            return;
        }
        
        self.is_searching_content = true;
        
        let search_query = self.search_in_files_query.clone();
        let files_to_search: Vec<FileItem> = self.file_tree.iter()
            .filter(|item| !item.is_directory && !item.is_binary)
            .cloned()
            .collect();
        
        let (result_sender, result_receiver) = mpsc::unbounded_channel();
        self.content_search_receiver = Some(Arc::new(tokio::sync::Mutex::new(result_receiver)));
        
        // Spawn async content search task
        std::thread::spawn(move || {
            let rt = tokio::runtime::Runtime::new().unwrap();
            rt.block_on(async move {
                let mut matching_files = Vec::new();
                
                for file_item in files_to_search {
                    if let Ok(content) = std::fs::read_to_string(&file_item.path) {
                        if content.to_lowercase().contains(&search_query.to_lowercase()) {
                            matching_files.push(file_item);
                        }
                    }
                    
                    // Yield control periodically
                    if matching_files.len() % 50 == 0 {
                        tokio::task::yield_now().await;
                    }
                }
                
                let _ = result_sender.send(matching_files);
            });
        });
    }
    
    pub fn render_progress_overlay(&mut self, ctx: &egui::Context) {
        if let Some(progress) = &self.scan_progress.clone() {
            let is_complete = progress.processed >= progress.total && progress.status.contains("Complete");
            
            egui::Window::new(if is_complete { "Complete!" } else { "Progress" })
                .collapsible(false)
                .resizable(false)
                .anchor(egui::Align2::CENTER_CENTER, [0.0, 0.0])
                .show(ctx, |ui| {
                    ui.vertical_centered(|ui| {
                        if is_complete {
                            ui.heading("✅ Generation Complete!");
                        } else {
                            ui.heading("⏳ Processing...");
                        }

                        let progress_fraction = if progress.total > 0 {
                            progress.processed as f32 / progress.total as f32
                        } else {
                            0.0
                        };

                        ui.add(egui::ProgressBar::new(progress_fraction)
                            .text(format!("{}/{}", progress.processed, progress.total)));

                        ui.label(&progress.status);

                        if let Some(file_name) = progress.current_file.file_name() {
                            ui.label(format!("File: {}", file_name.to_string_lossy()));
                        }

                        // Zusätzliche Infos bei Completion
                        if is_complete {
                            if let Some(size) = progress.file_size {
                                ui.label(format!("File size: {}", format_file_size(size)));
                            }
                            if let Some(lines) = progress.line_count {
                                ui.label(format!("Lines: {}", format_number_with_separators(lines)));
                            }
                        }
                        
                        ui.separator();
                        
                        ui.horizontal(|ui| {
                            if is_complete {
                                if ui.button("📁 Show in Finder").clicked() {
                                    self.open_output_in_finder();
                                    // DON'T close the dialog - let it stay open
                                }
                                if ui.button("✅ Close").clicked() {
                                    self.is_scanning = false;
                                    self.scan_progress = None;
                                }
                            } else {
                                if ui.button("❌ Cancel").clicked() {
                                    self.is_scanning = false;
                                    self.scan_progress = None;
                                }
                            }
                        });
                    });
                });
        }
    }
    
    pub fn render_large_files_warning(&mut self, ctx: &egui::Context) {
        egui::Window::new("⚠️ Large Files Detected")
            .collapsible(false)
            .resizable(true)
            .default_width(500.0)
            .default_height(300.0)
            .anchor(egui::Align2::CENTER_CENTER, [0.0, 0.0])
            .show(ctx, |ui| {
                ui.vertical(|ui| {
                    ui.heading("⚠️ Large Files Skipped");
                    
                    ui.add_space(10.0);
                    
                    ui.label(format!("{} files were skipped because they exceed the 100MB limit.", self.large_files_count));
                    ui.label("These files are not included in the scan for performance reasons.");
                    
                    ui.add_space(10.0);
                    
                    // Show list of skipped files
                    ui.label("Skipped files:");
                    egui::ScrollArea::vertical()
                        .max_height(150.0)
                        .show(ui, |ui| {
                            for file_name in &self.large_files_names {
                                ui.label(format!("• {}", file_name));
                            }
                        });
                    
                    ui.add_space(10.0);
                    
                    ui.horizontal(|ui| {
                        if ui.button("✅ OK").clicked() {
                            self.show_large_files_warning = false;
                            self.large_files_count = 0;
                            self.large_files_names.clear();
                        }
                        
                        if ui.button("📋 Show in Logs").clicked() {
                            // Actually write to logs
                            tracing::warn!("=== {} Large Files (>100MB) Skipped ===", self.large_files_count);
                            for file_name in &self.large_files_names {
                                tracing::warn!("Skipped: {}", file_name);
                            }
                            tracing::warn!("=== End Large Files List ===");
                            
                            self.show_large_files_warning = false;
                            self.large_files_count = 0;
                            self.large_files_names.clear();
                        }
                    });
                });
            });
    }

    fn open_output_in_finder(&self) {
        let output_path = PathBuf::from(&self.output_path);
        
        #[cfg(target_os = "macos")]
        {
            std::process::Command::new("open")
                .arg(&output_path)
                .spawn()
                .ok();
        }
        
        #[cfg(target_os = "windows")]
        {
            std::process::Command::new("explorer")
                .arg(&output_path)
                .spawn()
                .ok();
        }
        
        #[cfg(target_os = "linux")]
        {
            std::process::Command::new("xdg-open")
                .arg(&output_path)
                .spawn()
                .ok();
        }
    }
}
----------------------------------------------------

/Users/penrose/dev/D/context-file-concat/src/core/scanner.rs
----------------------------------------------------
use std::path::Path;
use std::collections::HashSet;
use tokio::sync::mpsc;
use walkdir::WalkDir;
use anyhow::Result;

use super::{FileItem, ScanProgress};
use crate::utils::file_detection::is_text_file;

pub struct DirectoryScanner {
    ignore_patterns: HashSet<String>,
}

impl DirectoryScanner {
    pub fn new(ignore_patterns: HashSet<String>) -> Self {
        Self { ignore_patterns }
    }
    
    pub async fn scan_directory(
        &self,
        root_path: &Path,
        progress_sender: mpsc::UnboundedSender<ScanProgress>,
    ) -> Result<(Vec<FileItem>, usize, Vec<String>)> {
        let mut files = Vec::new();
        let mut processed = 0;
        let mut large_files_count = 0;
        let mut large_files_names = Vec::new();

        progress_sender.send(ScanProgress {
            current_file: root_path.to_path_buf(),
            processed: 0,
            total: 0, // Unknown until complete
            status: "Starting scan...".to_string(),
            file_size: None,
            line_count: None,
        })?;

        // Single pass: process items directly without counting first
        for entry in WalkDir::new(root_path) {
            let entry = match entry {
                Ok(entry) => entry,
                Err(e) => {
                    tracing::warn!("Failed to access entry: {}", e);
                    continue;
                }
            };
            
            let path = entry.path();
            
            // Quick ignore check before expensive operations
            if self.should_ignore(path) {
                continue;
            }
            
            let metadata = match entry.metadata() {
                Ok(metadata) => metadata,
                Err(e) => {
                    tracing::warn!("Failed to get metadata for {}: {}", path.display(), e);
                    continue;
                }
            };
            
            let is_directory = metadata.is_dir();
            let size = metadata.len();
            
            // Check file size limit (100MB)
            if !is_directory && size > 100 * 1024 * 1024 {
                large_files_count += 1;
                large_files_names.push(path.display().to_string());
                tracing::warn!("File {} exceeds 100MB limit, skipping", path.display());
                continue;
            }
            
            // Quick binary check - avoid expensive file operations
            let is_binary = if is_directory {
                false
            } else {
                !is_text_file(path).unwrap_or(false)
            };
            
            let depth = path.strip_prefix(root_path)
                .map(|p| p.components().count())
                .unwrap_or(0);
            
            let file_item = FileItem {
                path: path.to_path_buf(),
                is_directory,
                is_binary,
                size,
                depth,
                parent: path.parent().map(|p| p.to_path_buf()),
                children: Vec::new(),
            };
            
            files.push(file_item);
            processed += 1;
            
            // Send progress updates much less frequently
            if processed % 100 == 0 {
                let _ = progress_sender.send(ScanProgress {
                    current_file: path.to_path_buf(),
                    processed,
                    total: 0, // Still unknown
                    status: format!("Scanning... {} items", processed),
                    file_size: None,
                    line_count: None,
                });
            }
            
            // Yield control less frequently
            if processed % 500 == 0 {
                tokio::task::yield_now().await;
            }
        }

        progress_sender.send(ScanProgress {
            current_file: root_path.to_path_buf(),
            processed,
            total: processed, // Now we know total
            status: "Scan complete!".to_string(),
            file_size: None,
            line_count: None,
        })?;

        Ok((files, large_files_count, large_files_names))
    }
    
    fn should_ignore(&self, path: &Path) -> bool {
        let path_str = path.to_string_lossy();
        
        for pattern in &self.ignore_patterns {
            if pattern.ends_with('/') {
                // Directory pattern
                let dir_pattern = &pattern[..pattern.len() - 1];
                if path_str.contains(dir_pattern) {
                    return true;
                }
            } else if pattern.contains('*') || pattern.contains('?') {
                // Wildcard pattern
                let file_name = path.file_name()
                    .and_then(|name| name.to_str())
                    .unwrap_or("");
                if Self::wildcard_match(file_name, pattern) || Self::wildcard_match(&path_str, pattern) {
                    return true;
                }
            } else if pattern.starts_with('*') {
                // Simple extension pattern (legacy)
                let ext = &pattern[1..];
                if path_str.ends_with(ext) {
                    return true;
                }
            } else {
                // Exact match or contains
                if path_str.contains(pattern) {
                    return true;
                }
            }
        }
        
        // Default system ignores
        let file_name = path.file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("");
            
        matches!(file_name, ".DS_Store" | "Thumbs.db" | "desktop.ini")
    }

    fn wildcard_match(text: &str, pattern: &str) -> bool {
        let mut text_chars = text.chars().peekable();
        let mut pattern_chars = pattern.chars().peekable();
        
        while let Some(&pattern_char) = pattern_chars.peek() {
            match pattern_char {
                '*' => {
                    pattern_chars.next();
                    if pattern_chars.peek().is_none() {
                        return true;
                    }
                    let remaining_pattern: String = pattern_chars.collect();
                    while text_chars.peek().is_some() {
                        let remaining_text: String = text_chars.clone().collect();
                        if Self::wildcard_match(&remaining_text, &remaining_pattern) {
                            return true;
                        }
                        text_chars.next();
                    }
                    return false;
                }
                '?' => {
                    pattern_chars.next();
                    if text_chars.next().is_none() {
                        return false;
                    }
                }
                _ => {
                    pattern_chars.next();
                    if text_chars.next() != Some(pattern_char) {
                        return false;
                    }
                }
            }
        }
        text_chars.next().is_none()
    }    
}

impl Default for DirectoryScanner {
    fn default() -> Self {
        let mut ignore_patterns = HashSet::new();
        
        // Default ignore patterns
        ignore_patterns.insert("node_modules/".to_string());
        ignore_patterns.insert("target/".to_string());
        ignore_patterns.insert(".git/".to_string());
        ignore_patterns.insert("*.log".to_string());
        ignore_patterns.insert("*.tmp".to_string());
        
        Self { ignore_patterns }
    }
}
----------------------------------------------------

/Users/penrose/dev/D/context-file-concat/src/core/file_handler.rs
----------------------------------------------------
use std::path::{Path, PathBuf};
use std::fs;
use std::io::{BufRead, BufReader};
use anyhow::Result;
use tokio::sync::mpsc;

use super::ScanProgress;
use crate::utils::file_detection::is_text_file;

pub struct FileHandler;

impl FileHandler {
    pub async fn generate_concatenated_file(
        selected_files: &[PathBuf],
        output_path: &Path,
        include_tree: bool,
        tree_content: Option<String>,
        progress_sender: mpsc::UnboundedSender<ScanProgress>,
    ) -> Result<()> {
        let mut content = String::new();
        let total_files = selected_files.len();
        
        // Add header
        content.push_str("# ContextFileConcat Output\n");
        content.push_str(&format!("# Generated: {}\n", chrono::Local::now().format("%Y-%m-%d %H:%M:%S")));
        content.push_str(&format!("# Total files: {}\n", total_files));
        content.push_str("\n");
        
        // Process each file
        for (i, file_path) in selected_files.iter().enumerate() {
            progress_sender.send(ScanProgress {
                current_file: file_path.clone(),
                processed: i,
                total: total_files,
                status: format!("Processing file {}/{}", i + 1, total_files),
                file_size: None,
                line_count: None,
            })?;
            
            // Skip directories
            if file_path.is_dir() {
                continue;
            }
            
            // Check if file is text
            if !is_text_file(file_path).unwrap_or(false) {
                content.push_str(&format!("{}\n", file_path.display()));
                content.push_str("----------------------------------------------------\n");
                content.push_str("[BINARY FILE - CONTENT SKIPPED]\n");
                content.push_str("----------------------------------------------------\n\n");
                continue;
            }
            
            // Add file header
            content.push_str(&format!("{}\n", file_path.display()));
            content.push_str("----------------------------------------------------\n");
            
            // Read and add file content
            match Self::read_file_content(file_path) {
                Ok(file_content) => {
                    content.push_str(&file_content);
                    if !file_content.ends_with('\n') {
                        content.push('\n');
                    }
                }
                Err(e) => {
                    content.push_str(&format!("[ERROR READING FILE: {}]\n", e));
                }
            }
            
            content.push_str("----------------------------------------------------\n\n");
            
            // Yield control periodically
            if i % 10 == 0 {
                tokio::task::yield_now().await;
            }
        }
        
        // Add tree at the end if requested
        if include_tree {
            if let Some(tree) = tree_content {
                content.push_str("\n# DIRECTORY TREE\n");
                content.push_str("====================================================\n");
                content.push_str(&tree);
                content.push_str("====================================================\n");
            }
        }
        
        // Write final file
        progress_sender.send(ScanProgress {
            current_file: output_path.to_path_buf(),
            processed: total_files,
            total: total_files,
            status: "Writing output file...".to_string(),
            file_size: None,
            line_count: None,
        })?;
        
        fs::write(output_path, &content)?;

        // Berechne File-Statistiken
        let file_size = fs::metadata(output_path)?.len();
        let line_count = content.lines().count();

        progress_sender.send(ScanProgress {
            current_file: output_path.to_path_buf(),
            processed: total_files,
            total: total_files,
            status: "Complete!".to_string(),
            file_size: Some(file_size),
            line_count: Some(line_count),
        })?;
        
        tracing::info!("Successfully generated concatenated file: {}", output_path.display());
        Ok(())
    }
    
    fn read_file_content(file_path: &Path) -> Result<String> {
        // Check file size first (100MB limit)
        let metadata = fs::metadata(file_path)?;
        if metadata.len() > 100 * 1024 * 1024 {
            return Ok(format!("[FILE TOO LARGE: {} bytes - CONTENT SKIPPED]", metadata.len()));
        }
        
        // Try to read as UTF-8 first
        match fs::read_to_string(file_path) {
            Ok(content) => Ok(content),
            Err(_) => {
                // If UTF-8 fails, try reading as bytes and converting
                let bytes = fs::read(file_path)?;
                match String::from_utf8_lossy(&bytes) {
                    content if content.contains('\u{FFFD}') => {
                        Ok("[BINARY OR NON-UTF8 FILE - CONTENT SKIPPED]".to_string())
                    }
                    content => Ok(content.to_string()),
                }
            }
        }
    }
    
    pub fn get_file_preview(file_path: &Path, max_lines: usize) -> Result<String> {
        if file_path.is_dir() {
            return Ok("[DIRECTORY]".to_string());
        }
        
        if !is_text_file(file_path).unwrap_or(false) {
            return Ok("[BINARY FILE]".to_string());
        }
        
        let file = fs::File::open(file_path)?;
        let reader = BufReader::new(file);
        let mut preview = String::new();
        let mut line_count = 0;
        
        for line in reader.lines() {
            if line_count >= max_lines {
                preview.push_str("...\n[Preview truncated]");
                break;
            }
            
            match line {
                Ok(line_content) => {
                    preview.push_str(&line_content);
                    preview.push('\n');
                }
                Err(_) => {
                    preview.push_str("[ERROR READING LINE]\n");
                }
            }
            
            line_count += 1;
        }
        
        Ok(preview)
    }
    
    pub fn calculate_total_size(files: &[PathBuf]) -> u64 {
        files
            .iter()
            .filter_map(|path| fs::metadata(path).ok())
            .filter(|metadata| metadata.is_file())
            .map(|metadata| metadata.len())
            .sum()
    }
    
    pub fn estimate_output_size(files: &[PathBuf]) -> u64 {
        let content_size = Self::calculate_total_size(files);
        let overhead_per_file = 100; // Estimated overhead for headers and separators
        let total_overhead = files.len() as u64 * overhead_per_file;
        
        content_size + total_overhead
    }
}
----------------------------------------------------

/Users/penrose/dev/D/context-file-concat/src/utils/mod.rs
----------------------------------------------------
pub mod file_detection;
----------------------------------------------------

/Users/penrose/dev/D/context-file-concat/src/core/mod.rs
----------------------------------------------------
pub mod scanner;
pub mod file_handler;
pub mod search;
pub mod tree_generator;

use std::path::PathBuf;

#[derive(Debug, Clone)]
pub struct FileItem {
    pub path: PathBuf,
    pub is_directory: bool,
    pub is_binary: bool,
    pub size: u64,
    pub depth: usize,
    pub parent: Option<PathBuf>,
    pub children: Vec<PathBuf>,
}

#[derive(Debug, Clone)]
pub struct ScanProgress {
    pub current_file: PathBuf,
    pub processed: usize,
    pub total: usize,
    pub status: String,
    pub file_size: Option<u64>,
    pub line_count: Option<usize>,
}

#[derive(Debug, Clone)]
pub struct SearchFilter {
    pub query: String,
    pub extension: String,
    pub case_sensitive: bool,
    pub show_binary: bool,
    pub ignore_patterns: std::collections::HashSet<String>,
}

pub use scanner::DirectoryScanner;
pub use file_handler::FileHandler;
pub use search::SearchEngine;
pub use tree_generator::TreeGenerator;
----------------------------------------------------

/Users/penrose/dev/D/context-file-concat/src/config/mod.rs
----------------------------------------------------
pub mod settings;

use std::collections::HashSet;
use std::path::PathBuf;
use serde::{Deserialize, Serialize};
use anyhow::Result;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppConfig {
    pub ignore_patterns: HashSet<String>,
    pub last_directory: Option<PathBuf>,
    pub output_directory: Option<PathBuf>,
    pub case_sensitive_search: bool,
    pub show_binary_files: bool,
    pub include_tree_by_default: bool,
    pub remove_empty_directories: bool,
    pub window_size: (f32, f32),
    pub window_position: Option<(f32, f32)>,
}

impl AppConfig {
    pub fn load() -> Result<Self> {
        settings::load_config()
    }
    
    pub fn save(&self) -> Result<()> {
        settings::save_config(self)
    }
    
    pub fn config_dir() -> Option<PathBuf> {
        settings::get_config_directory()
    }
}

impl Default for AppConfig {
    fn default() -> Self {
        let mut ignore_patterns = HashSet::new();
        
        // Default ignore patterns
        ignore_patterns.insert("node_modules/".to_string());
        ignore_patterns.insert("target/".to_string());
        ignore_patterns.insert(".git/".to_string());
        ignore_patterns.insert("*.log".to_string());
        ignore_patterns.insert("*.tmp".to_string());
        ignore_patterns.insert(".DS_Store".to_string());
        ignore_patterns.insert("Thumbs.db".to_string());
        
        Self {
            ignore_patterns,
            last_directory: None,
            output_directory: dirs::desktop_dir(),
            case_sensitive_search: false,
            show_binary_files: true,
            include_tree_by_default: false,
            remove_empty_directories: false,
            window_size: (1200.0, 800.0),
            window_position: None,
        }
    }
}
----------------------------------------------------

/Users/penrose/dev/D/context-file-concat/src/core/tree_generator.rs
----------------------------------------------------
use std::path::{Path, PathBuf};
use std::collections::{HashMap, HashSet};

use super::FileItem;

pub struct TreeGenerator;

impl TreeGenerator {
    pub fn generate_tree(
        files: &[FileItem], 
        root_path: &Path,
        ignore_patterns: &HashSet<String>
    ) -> String {
        let mut tree_map = HashMap::new();
        
        // Build tree structure
        for file in files {
            if Self::should_ignore(&file.path, ignore_patterns) {
                continue;
            }
            
            let relative_path = file.path.strip_prefix(root_path)
                .unwrap_or(&file.path);
            
            Self::insert_into_tree(&mut tree_map, relative_path, file.is_directory);
        }
        
        // Generate ASCII representation
        let mut result = String::new();
        result.push_str(&format!("{}/\n", root_path.file_name().unwrap_or_default().to_string_lossy()));
        
        Self::render_tree_recursive(&tree_map, &mut result, "", true);
        
        result
    }
    
    fn insert_into_tree(
        tree_map: &mut HashMap<PathBuf, TreeNode>,
        path: &Path,
        is_directory: bool
    ) {
        let mut current_path = PathBuf::new();
        
        for component in path.components() {
            current_path.push(component);
            
            let is_final = current_path == path;
            let node_is_dir = if is_final { is_directory } else { true };
            
            tree_map.entry(current_path.clone()).or_insert_with(|| TreeNode {
                name: component.as_os_str().to_string_lossy().to_string(),
                is_directory: node_is_dir,
                children: Vec::new(),
            });
        }
        
        // Build parent-child relationships
        let paths: Vec<PathBuf> = tree_map.keys().cloned().collect();
        for path in paths {
            if let Some(parent_path) = path.parent() {
                if parent_path != Path::new("") {
                    if let Some(parent_node) = tree_map.get_mut(parent_path) {
                        if !parent_node.children.contains(&path) {
                            parent_node.children.push(path.clone());
                        }
                    }
                }
            }
        }
    }
    
    fn render_tree_recursive(
        tree_map: &HashMap<PathBuf, TreeNode>,
        result: &mut String,
        prefix: &str,
        is_root: bool
    ) {
        // Get root nodes (nodes without parents in the current context)
        let mut root_nodes: Vec<&PathBuf> = if is_root {
            tree_map.keys()
                .filter(|path| {
                    path.parent().map_or(true, |p| p == Path::new(""))
                })
                .collect()
        } else {
            vec![]
        };
        
        root_nodes.sort_by(|a, b| {
            let a_node = &tree_map[*a];
            let b_node = &tree_map[*b];
            
            // Directories first, then files
            match (a_node.is_directory, b_node.is_directory) {
                (true, false) => std::cmp::Ordering::Less,
                (false, true) => std::cmp::Ordering::Greater,
                _ => a_node.name.cmp(&b_node.name),
            }
        });
        
        for (i, path) in root_nodes.iter().enumerate() {
            let node = &tree_map[*path];
            let is_last = i == root_nodes.len() - 1;
            
            let connector = if is_last { "└── " } else { "├── " };
            let icon = if node.is_directory { "📁 " } else { "📄 " };
            
            result.push_str(&format!("{}{}{}{}\n", 
                prefix, connector, icon, node.name));
            
            // Recursively render children
            if !node.children.is_empty() {
                let new_prefix = if is_last {
                    format!("{}    ", prefix)
                } else {
                    format!("{}│   ", prefix)
                };
                
                Self::render_children(tree_map, &node.children, result, &new_prefix);
            }
        }
    }
    
    fn render_children(
        tree_map: &HashMap<PathBuf, TreeNode>,
        children: &[PathBuf],
        result: &mut String,
        prefix: &str
    ) {
        let mut sorted_children: Vec<&PathBuf> = children.iter().collect();
        sorted_children.sort_by(|a, b| {
            let a_node = &tree_map[*a];
            let b_node = &tree_map[*b];
            
            // Directories first, then files
            match (a_node.is_directory, b_node.is_directory) {
                (true, false) => std::cmp::Ordering::Less,
                (false, true) => std::cmp::Ordering::Greater,
                _ => a_node.name.cmp(&b_node.name),
            }
        });
        
        for (i, path) in sorted_children.iter().enumerate() {
            let node = &tree_map[*path];
            let is_last = i == sorted_children.len() - 1;
            
            let connector = if is_last { "└── " } else { "├── " };
            let icon = if node.is_directory { "📁 " } else { "📄 " };
            
            result.push_str(&format!("{}{}{}{}\n", 
                prefix, connector, icon, node.name));
            
            // Recursively render children
            if !node.children.is_empty() {
                let new_prefix = if is_last {
                    format!("{}    ", prefix)
                } else {
                    format!("{}│   ", prefix)
                };
                
                Self::render_children(tree_map, &node.children, result, &new_prefix);
            }
        }
    }
    
    fn should_ignore(path: &Path, ignore_patterns: &HashSet<String>) -> bool {
        let path_str = path.to_string_lossy();
        
        for pattern in ignore_patterns {
            if pattern.ends_with('/') {
                let dir_pattern = &pattern[..pattern.len() - 1];
                if path_str.contains(dir_pattern) {
                    return true;
                }
            } else if pattern.starts_with('*') {
                let ext = &pattern[1..];
                if path_str.ends_with(ext) {
                    return true;
                }
            } else if path_str.contains(pattern) {
                return true;
            }
        }
        
        false
    }
}

#[derive(Debug, Clone)]
struct TreeNode {
    name: String,
    is_directory: bool,
    children: Vec<PathBuf>,
}
----------------------------------------------------

/Users/penrose/dev/D/context-file-concat/src/core/search.rs
----------------------------------------------------
use regex::Regex;
use std::path::Path;

use super::{FileItem, SearchFilter};

pub struct SearchEngine;

impl SearchEngine {
    pub fn filter_files(files: &[FileItem], filter: &SearchFilter) -> Vec<FileItem> {
        files
            .iter()
            .filter(|file| Self::matches_filter(file, filter))
            .cloned()
            .collect()
    }
    
    fn matches_filter(file: &FileItem, filter: &SearchFilter) -> bool {
        // Check if binary files should be shown
        if file.is_binary && !filter.show_binary {
            return false;
        }
        
        // Check ignore patterns
        if Self::matches_ignore_patterns(&file.path, &filter.ignore_patterns) {
            return false;
        }
        
        // Check search query
        if !filter.query.is_empty() && !Self::matches_search_query(&file.path, &filter.query, filter.case_sensitive) {
            return false;
        }
        
        // Check file extension filter
        if !filter.extension.is_empty() && !Self::matches_extension(&file.path, &filter.extension) {
            return false;
        }
        
        true
    }
    
    fn matches_ignore_patterns(path: &Path, ignore_patterns: &std::collections::HashSet<String>) -> bool {
        let path_str = path.to_string_lossy();
        let file_name = path.file_name()
            .and_then(|name| name.to_str())
            .unwrap_or("");
        
        for pattern in ignore_patterns {
            if pattern.ends_with('/') {
                // Directory pattern
                let dir_pattern = &pattern[..pattern.len() - 1];
                if path_str.contains(dir_pattern) {
                    return true;
                }
            } else if pattern.contains('*') || pattern.contains('?') {
                // Wildcard pattern - check against filename
                if Self::wildcard_match(file_name, pattern) {
                    return true;
                }
                // Also check against full path for directory patterns
                if Self::wildcard_match(&path_str, pattern) {
                    return true;
                }
            } else if pattern.starts_with('*') {
                // Simple extension pattern (legacy support)
                let ext = &pattern[1..];
                if path_str.ends_with(ext) {
                    return true;
                }
            } else {
                // Exact match or contains
                if path_str.contains(pattern) {
                    return true;
                }
            }
        }
        
        false
    }

    // NEW: Wildcard matching function
    fn wildcard_match(text: &str, pattern: &str) -> bool {
        let mut text_chars = text.chars().peekable();
        let mut pattern_chars = pattern.chars().peekable();
        
        while let Some(&pattern_char) = pattern_chars.peek() {
            match pattern_char {
                '*' => {
                    pattern_chars.next(); // consume '*'
                    
                    // If * is the last character, match everything remaining
                    if pattern_chars.peek().is_none() {
                        return true;
                    }
                    
                    // Try to match the rest of the pattern at each position
                    let remaining_pattern: String = pattern_chars.collect();
                    while text_chars.peek().is_some() {
                        let remaining_text: String = text_chars.clone().collect();
                        if Self::wildcard_match(&remaining_text, &remaining_pattern) {
                            return true;
                        }
                        text_chars.next();
                    }
                    return false;
                }
                '?' => {
                    pattern_chars.next(); // consume '?'
                    if text_chars.next().is_none() {
                        return false; // ? must match exactly one character
                    }
                }
                _ => {
                    pattern_chars.next(); // consume pattern char
                    if text_chars.next() != Some(pattern_char) {
                        return false;
                    }
                }
            }
        }
        
        // Both should be exhausted for a complete match
        text_chars.next().is_none()
    }
    
    fn matches_search_query(path: &Path, query: &str, case_sensitive: bool) -> bool {
        // Only check the actual filename, not the full path
        let file_name = path.file_name()
            .and_then(|name| name.to_str())
            .unwrap_or("");
        
        if case_sensitive {
            file_name.contains(query)
        } else {
            let query_lower = query.to_lowercase();
            file_name.to_lowercase().contains(&query_lower)
        }
    }
    
    fn matches_extension(path: &Path, extension_filter: &str) -> bool {
        if let Some(ext) = path.extension().and_then(|ext| ext.to_str()) {
            let filter = if extension_filter.starts_with('.') {
                &extension_filter[1..]
            } else {
                extension_filter
            };
            
            ext.eq_ignore_ascii_case(filter)
        } else {
            // If file has no extension, only match if filter is empty or "no extension"
            extension_filter.is_empty() || extension_filter == "no extension"
        }
    }
    
    pub fn build_regex_filter(pattern: &str, case_sensitive: bool) -> Result<Regex, regex::Error> {
        let flags = if case_sensitive { "" } else { "(?i)" };
        let full_pattern = format!("{}{}", flags, pattern);
        Regex::new(&full_pattern)
    }
    
    pub fn filter_with_regex(files: &[FileItem], regex: &Regex) -> Vec<FileItem> {
        files
            .iter()
            .filter(|file| {
                let file_name = file.path.file_name()
                    .and_then(|name| name.to_str())
                    .unwrap_or("");
                regex.is_match(file_name)
            })
            .cloned()
            .collect()
    }
    
    pub fn get_file_extensions(files: &[FileItem]) -> Vec<String> {
        let mut extensions = std::collections::HashSet::new();
        
        for file in files {
            if !file.is_directory {
                if let Some(ext) = file.path.extension().and_then(|ext| ext.to_str()) {
                    extensions.insert(format!(".{}", ext));
                }
            }
        }
        
        let mut ext_vec: Vec<String> = extensions.into_iter().collect();
        ext_vec.sort();
        ext_vec
    }
}
----------------------------------------------------


# DIRECTORY TREE
====================================================
context-file-concat/
└── 📁 src
    ├── 📁 app
    │   ├── 📄 main_window.rs
    │   └── 📄 mod.rs
    ├── 📁 config
    │   ├── 📄 mod.rs
    │   └── 📄 settings.rs
    ├── 📁 core
    │   ├── 📄 file_handler.rs
    │   ├── 📄 mod.rs
    │   ├── 📄 scanner.rs
    │   ├── 📄 search.rs
    │   └── 📄 tree_generator.rs
    ├── 📁 utils
    │   ├── 📄 file_detection.rs
    │   └── 📄 mod.rs
    └── 📄 main.rs
====================================================
